# Chapter 1 재귀
## 반복과 재귀
### 가방에서 열쇠 찾기 문제
어떠한 가방에서 열쇠를 찾아야 하는 상황이라고 가정해보자. 이때 이 가방안에는 또 작은 가방들이 있을 수 있고 그 작은 가방안에 더 작은 가방이 존재할 수 있는 상황이다.
그리고 그 가방들 사이에 열쇠가 있는 하나의 가방이 존재한다. 이 가방들에서 열쇠를 찾는 방법은 무엇이 있을까?

### 반복 방식
반복 방식의 `의사코드(Pseudocode)`는 아래와 같이 작성할 수 있다.
1. 확인할 상자를 `나중에 확인할 상자 목록`에 넣는다.
2. 상자중 하나를 확인한다.
3. 만약 안에 상자가 있다면 `나중에 확인할 상자 목록`에 넣는다.
4. 만약 열쇠가 있으면 작업을 종료한다.
5. 위의 작업을 반복한다.

[Code](FindKeyWithIteration.kt)

### 재귀 방식
재귀 방식의 `의사코드(Pseudocode)`는 아래와 같이 작성할 수 있다.
1. 상자 안을 확인한다.
2. 상자를 발견하면 1단계로 간다.
3. 열쇠를 발견하면 작업을 종료한다.

[Code](FindKeyWithRecursion.kt)

### 반복과 재귀 방식의 차이
두가지 방식 모두 동일한 결과를 내지만 재귀 방식 풀이가 더 명확하게 느껴질 수 있다. 하지만 재귀를 쓰면 성능적 이점은 없고 오히려 `스택 오버플로우` 같은 문제가 발생할수도 있다.

## 기본 단계와 재귀 단계
재귀 함수는 자기 자신을 호출하기 때문에 실수로 무한 반복하는 코드를 작성하기 쉽다. 그렇기에 모든 재귀 함수는 재귀를 하는 부분, 재귀를 멈추는 부분으로 이루어져야 한다.
여기서 재귀를 하는 부분을 `재귀 단계(Recursion Case)`, 재귀를 종료하는 부분을 `기본 단계(Base Case)`라고 한다.

## 스택
모든 프로그래밍의 함수들은 `스택(Stack)`구조로 호출된다. 예를 들어 함수 A에서 B를 호출하면 A위 B가 쌓이는 형태이다. 그 후 B의 동작이 종료되면 스택에서 제거된다.

### 재귀 함수에서의 스택
재귀 함수는 자기 자신을 계속 호출하는 형태이기에 반복이 많아질수록 여러번 스택에 쌓이게 된다. 스택에선 콜러의 정보들도 계속 갖고 있어야 하므로 메모리 문제가 생길 수 있다.
이러한 문제를 해결하기 위해선 `재귀 대신 반복문을 사용`, `꼬리 재귀(Tail Recursion`을 사용하는 방법을 택할 수 있다. (꼬리 재귀는 모든 프로그래밍 언어에서 지원하지는 않는다. [wiki](https://en.wikipedia.org/wiki/Tail_call)) 