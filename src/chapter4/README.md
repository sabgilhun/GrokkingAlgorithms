# Chapter 4 퀵 정렬
## 분할 정복
분할 정복은 재귀적 문제 해결 방법중 하나이다.

### 농장 토지 나누기 문제
임의의 직사각형 형태의 토지를 갖고 있는 농장을 최대한 큰 정사각형으로 나누는 방법을 찾는 문제를 상상해보자.

### 분할 정복으로 풀기
분할 정복을 적용하는 기본적인 단계는 아래와 같다.
1. 기본 단계를 해결한다. 이 부분은 가능한 간단한 문제여야 한다.
2. 문제가 기본 단계가 될 때까지 나누거나 작게 만든다.

토지가 50 x 25의 직사각형이라고 해보자. 이 농지를 나눌 수 있는 가장 큰 정사각형은 25 x 25 이다. 
이 조건을 더 일반화 시키면 `높이와 너비 중 작은 값으로 나눈다.` `나누어 떨어지면 그 값이 토지를 나눌 수 있는 정사각형의 한변 길이이다.` 
그럼 나누어지지 않는 경우엔 어떨까? 나누어지지 않는 경우엔 남은 토지 영역으로 `높이와 너비 중 작은 값으로 나눈다.`를 다시 해본다. 이를 기본 단계인 `나누어 떨어지면`까지 진행하는 것이다.

위의 알고리즘은 기본 단계와 재귀 단계를 나누어보자.
* 기본 단계: 높이, 너비 중 작은 값으로 다른 값이 나누어 떨어진다면 그 값 반환
* 재귀 단게:  높이, 너비 중 작은 값으로 다른 값이 나누어 떨어지지 않는다면 남음 영역으로 재귀 단계 반복

이 방식을 일반화 하면 아래와 같이 표현 가능하다.
1. 가장 간단한 경우로 기본 단계 설정
2. 주어진 문제를 기본 단계가 되도록 문제를 작게 만들어 보기

## 퀵 정렬
`퀵 정렬(Quick Sort)`은 선택 정렬보다 훨씬 빠른 정렬 알고리즘이다.

### 기본 단계 정하기
앞서 설명한 것처럼 가장 간단한 경우를 기본 단계로 설정하면 된다. 정렬에서 가장 간단한 경우는 정렬할 필요가 없는 배열이다.
바로 `비어 있는 배열`, `원소가 하나인 배열`을 말한다. 

### 문제를 작게 만들기
기준 원소를 정하고 그 원소보다 작은 배열, 큰 배열로 나눈다(`문제 작게 만들기`). 나뉜 배열에서도 동일한 작업을 반복한다.

### 의사 코드
1. 배열이 비어 있거나 1개의 원소만 갖는다면 반환
2. 1이 아니면, 배열에서 기준 원소 설정
3. 기준 원소보다 작은 배열, 큰 배열로 분리
4. 하위 배열에 대해 1, 2, 3 동작

[Code](QuickSort.kt)
 
## 퀵 정렬의 빅오 표기법
### 퀵 정렬의 최선/최악의 경우 빅오 표기법
퀵 정렬은 기준 원소를 어떻게 정하냐에 따라 성능이 크게 달라진다.
* 최악의 상황은 `기준 원소가 항상 첫 번째 원소를 고를 경우`이다. 이 경우엔 호출 스택이 배열의 크기만큼 커지게 되며 실행 시간은 `O(n^2)`이 된다.
* 최선의 상황은 `기준 원소가 항상 배열의 중앙 값이 되는 경우`이다. 이 경우엔 호출 스택이 log n 크기이기 때문에  실행 시간은 `O(n*log n)`이 된다.
  
### 상수 시간
`O(n)`에서 n은 n이 커질수록 어떠한 차수로 시간이 늘어나는지를 표시해준다. 하지만 실제론 이에 상수 시간도 영향을 준다.
한마디로 `1 * n < 2 * n` 이런식으로 1, 2와 같은 상수 시간의 크기가 실제 프로그램의 성능을 바꾸기도 한다.
실제로 `병합 정렬(Merge Sort)`과 퀵 정렬의 경우 동일한 `O(n*log n)`의 실행 시간을 갖는데, 퀵 정렬의 최악의 상황을 상정하더라도 병합 정렬의 상수 시간이 크기 때문에 퀵 정렬이 일반적인 상황에서 더 빠르다. 
 
 